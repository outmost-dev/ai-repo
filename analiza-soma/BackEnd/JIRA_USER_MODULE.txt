================================================================================
JIRA STORY: USER MODULE
================================================================================

Title: User Module

Description:
Modulul User gestioneazÄƒ toate operaÈ›iunile legate de utilizatori: vizualizare profil, actualizare date personale, upload/download imagini profil, export CSV, cÄƒutare utilizatori, operaÈ›iuni bulk (mass activation emails, MailerLite sync), È™i management de adrese de facturare. Include funcÈ›ionalitÄƒÈ›i complexe de access control bazat pe subscriptions È™i cache Redis.

LocaÈ›ie cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts
- Service: src/v1/User/Service/user.service.ts
- Module: src/v1/User/user.module.ts

Endpoints implementate: 16

Services utilizate:
- UserService (Service/user.service.ts)
- SubscriptionsRepository (shared/Repositories/subscriptions.repository.ts)
- SubscriptionTypesRepository (shared/Repositories/subscriptionTypes.repository.ts)
- InvoicesRepository (shared/Repositories/invoices.repository.ts)
- AddressesRepository (shared/Repositories/addresses.repository.ts)
- MailerService (Postmark SMTP - @nestjs-modules/mailer)
- MailerLiteService (shared/Services/mailerlite.service.ts)
- DOSpacesService (DigitalOcean Spaces - AWS SDK compatible)
- StripeService (din Stripe Module)
- RedisService (shared/Services/redis.service.ts)

Repositories:
- UsersRepository
- SubscriptionsRepository
- SubscriptionTypesRepository
- InvoicesRepository
- AddressesRepository

Dependencies:
- Redis (access control cache + category access)
- DigitalOcean Spaces (profile image storage)
- Stripe (customer management)
- Postmark (activation emails, password setup emails)
- MailerLite (marketing groups management)
- CSV Writer (export functionality)
- Argon2 (password hashing)
- JWT (email validation tokens)

Guards utilizaÈ›i:
- AuthGuard('jwt') - toate endpoint-urile necesitÄƒ autentificare
- RolesGuard - verificare ADMIN role pentru endpoint-uri privilegiate
- AuthGuard('email-validation') - pentru verify-updated-email

Authorization Roles:
- ADMIN - acces complet la toate operaÈ›iunile
- CLIENT - acces limitat la propriul profil
- USER - poate disable propriul cont

Notes:
- Access control system complex: ADMIN, STANDARD, COURSE_BASED, NO_ACCESS
- Redis cache pentru access rights (TTL configurable via ACCESS_CACHE_LIFECYCLE)
- Profile images stocate Ã®n DigitalOcean Spaces (directory: users/)
- CSV export include subscriptions, analytics time, campaigns
- Mass operations pentru email activation È™i MailerLite sync
- Admin poate crea users cu subscriptions È™i Stripe customers
- Update email necesitÄƒ verificare prin email token
- Delete user È™terge cascadÄƒ: invoices + subscriptions + user

Access Types (cached Ã®n Redis):
- ACCESS_TYPE.ADMIN - admin complet access
- ACCESS_TYPE.STANDARD - subscription standard (toate cursurile)
- ACCESS_TYPE.COURSE_BASED - subscription pe categorii specifice
- ACCESS_TYPE.NO_ACCESS - fÄƒrÄƒ subscription activÄƒ

================================================================================
TASKS
================================================================================

--------------------------------------------------------------------------------
TASK 1: GET /v1/user/:userId
--------------------------------------------------------------------------------

Title: GET /v1/user/:userId

Description:

Business Logic:
1. PrimeÈ™te userId ca parametru Ã®n URL
2. VerificÄƒ dacÄƒ user-ul autentificat poate accesa profilul solicitat:
   - DacÄƒ authUser.id === userId â†’ permite access (propriul profil)
   - DacÄƒ authUser.role === ADMIN â†’ permite access (admin vede orice profil)
   - Altfel â†’ aruncÄƒ BadRequestException "User not found or access is restricted"
3. CautÄƒ user-ul Ã®n baza de date dupÄƒ userId
4. DacÄƒ user-ul nu existÄƒ, aruncÄƒ BadRequestException "User not found"
5. ReturneazÄƒ user object cu toate detaliile profilului
6. User object e wrappat Ã®ntr-o clasÄƒ User().init() care filtreazÄƒ cÃ¢mpurile sensitive

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:41-52
- Service: src/v1/User/Service/user.service.ts:191-205

Request:
GET /v1/user/123
Headers: Authorization: Bearer {accessToken}

Response (Success 200):
{
  "id": 123,
  "fullName": "John Doe",
  "email": "john@example.com",
  "phone": "+40123456789",
  "role": "CLIENT",
  "status": 2,
  "isActive": true,
  "marketingAgreement": true,
  "whatsappAgreement": false,
  "hasPicture": false,
  "profileVersion": 1,
  "createdAt": "2024-01-01T00:00:00.000Z",
  "updatedAt": "2024-01-15T00:00:00.000Z"
}

Response (Error 400 - access denied):
{
  "statusCode": 400,
  "message": "User not found or access is restricted {authUserId}, {requestedUserId}"
}

Response (Error 400 - not found):
{
  "statusCode": 400,
  "message": "User not found"
}

Authorization: AuthGuard('jwt') - requires valid access token

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.getUserById()

Notes:
- User object filtreazÄƒ password, recoveryKey, È™i alte cÃ¢mpuri sensibile
- Admin poate vedea orice profil
- User-ii normali pot vedea doar propriul profil

--------------------------------------------------------------------------------
TASK 2: GET /v1/user/all
--------------------------------------------------------------------------------

Title: GET /v1/user/all

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. PrimeÈ™te query params pentru paginare: page, limit
3. PrimeÈ™te optional param analytics (boolean) pentru a include date analytics
4. ReturneazÄƒ lista paginatÄƒ de users cu:
   - Array users
   - Total count
   - Pagination metadata
5. DacÄƒ nu existÄƒ users, aruncÄƒ BadRequestException "No user found"
6. Fiecare user object e wrappat Ã®n User().init()

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:54-61
- Service: src/v1/User/Service/user.service.ts:294-300

Request:
GET /v1/user/all?page=1&limit=50&analytics=true
Headers: Authorization: Bearer {accessToken}

Query Parameters:
- page (number, optional): default 1
- limit (number, optional): default 50
- analytics (boolean, optional): include analytics data if true

Response (Success 200):
{
  "users": [
    {
      "id": 123,
      "fullName": "John Doe",
      "email": "john@example.com",
      "phone": "+40123456789",
      "role": "CLIENT",
      "status": 2,
      "subscriptions": [...],
      "analytics": [...] (if analytics=true)
    },
    ...
  ],
  "count": 1500,
  "page": 1,
  "limit": 50,
  "totalPages": 30
}

Response (Error 400 - no users):
{
  "statusCode": 400,
  "message": "No user found"
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.getAllUsers()

Notes:
- Analytics param opÈ›ional include time spent È™i user events
- Pagination e configurabilÄƒ
- Endpoint folosit de admin dashboard pentru user management

--------------------------------------------------------------------------------
TASK 3: GET /v1/user/export-all
--------------------------------------------------------------------------------

Title: GET /v1/user/export-all

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. ExportÄƒ toÈ›i users Ã®ntr-un fiÈ™ier CSV
3. Include pentru fiecare user:
   - Date personale (ID, nume, email, telefon, data creÄƒrii)
   - Subscriptions (titlu abonament, tip, status, expirare)
   - Time spent total pe platformÄƒ (agregat din analytics)
   - Campaigns asociate
4. DacÄƒ un user are multiple subscriptions, creeazÄƒ cÃ¢te un rÃ¢nd per subscription
5. DacÄƒ user-ul nu are subscriptions, creeazÄƒ un rÃ¢nd cu "N/A"
6. Formatul CSV: header + rows
7. ReturneazÄƒ CSV file cu Content-Type: text/csv È™i Content-Disposition: attachment

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:63-75
- Service: src/v1/User/Service/user.service.ts:216-292

Request:
GET /v1/user/export-all?page=1&limit=10000
Headers: Authorization: Bearer {accessToken}

Query Parameters:
- page (number, optional): pentru export parÈ›ial
- limit (number, optional): pentru export parÈ›ial

Response (Success 200):
Content-Type: text/csv
Content-Disposition: attachment; filename=data.csv

CSV Content:
ID,Nume,Email,Telefon,Cont creat la,Titlu Abonament,Tip Abonament,Abonament Status,Abonament Expirare,Campanii,All time pe platforma
123,John Doe,john@example.com,+40123456789,01/15/2024 10:30,Abonament Premium (id: 50),STANDARD,Activ,12/31/2024,"Campaign 1, Campaign 2",3600
124,Jane Smith,jane@example.com,+40987654321,02/01/2024 14:20,N/A,,,,Campaign 3,1200

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.getUsersForExport()
- SubscriptionTypesRepository.getAllTypesList()
- csv-writer package

CSV Columns:
1. ID - user ID
2. Nume - fullName
3. Email - email address
4. Telefon - phone number
5. Cont creat la - createdAt (format: MM/DD/YYYY HH:mm)
6. Titlu Abonament - subscription type title with ID
7. Tip Abonament - subscription form (STANDARD, COURSE_BASED, FREE)
8. Abonament Status - Activ / Expired
9. Abonament Expirare - endDate (format: MM/DD/YYYY)
10. Campanii - comma-separated campaign titles
11. All time pe platforma - total seconds spent (aggregated from analyticsTime)

Notes:
- Time spent e calculat agregÃ¢nd toate analyticsTime entries
- Subscriptions sunt flatened (un user cu 3 subs = 3 rows Ã®n CSV)
- Status "Activ" = endDate >= now && status == PAYMENT_ACCEPTED
- Formatul datelor e localizat (MM/DD/YYYY pentru export)

--------------------------------------------------------------------------------
TASK 4: GET /v1/user/search
--------------------------------------------------------------------------------

Title: GET /v1/user/search

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. CautÄƒ users dupÄƒ:
   - Email (partial match)
   - Nume (partial match)
   - Telefon (partial match)
3. Minimum 3 caractere pentru cÄƒutare (validare)
4. Query param withCampaign (boolean) - dacÄƒ true, include campaigns Ã®n rezultate
5. ReturneazÄƒ lista de users matching search criteria
6. DacÄƒ searchValue < 3 caractere, aruncÄƒ "Search value must be greater than 2 characters"

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:77-84
- Service: src/v1/User/Service/user.service.ts:327-337

Request:
GET /v1/user/search?searchValue=john&withCampaign=true
Headers: Authorization: Bearer {accessToken}

Query Parameters:
- searchValue (string, required): minimum 3 characters
- withCampaign (boolean, optional): include campaigns data

Response (Success 200):
{
  "users": [
    {
      "id": 123,
      "fullName": "John Doe",
      "email": "john@example.com",
      "phone": "+40123456789",
      "campaigns": [...] (if withCampaign=true)
    },
    {
      "id": 456,
      "fullName": "Johnny Smith",
      "email": "johnny@example.com",
      "phone": "+40111222333"
    }
  ],
  "count": 2
}

Response (Error 400 - search too short):
{
  "statusCode": 400,
  "message": "Search value must be greater than 2 characters"
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.searchUser()

Notes:
- Search e case-insensitive
- CautÄƒ Ã®n email, fullName, È™i phone
- Partial match (LIKE query)
- withCampaign param opÈ›ional pentru a evita over-fetching

--------------------------------------------------------------------------------
TASK 5: GET /v1/user/profile-image
--------------------------------------------------------------------------------

Title: GET /v1/user/profile-image

Description:

Business Logic:
1. PrimeÈ™te email ca query parameter
2. NOTA: Implementarea curentÄƒ IGNORÄ‚ email-ul È™i returneazÄƒ Ã®ntotdeauna default image
3. CiteÈ™te imaginea default din: public/default-users.jpg
4. ReturneazÄƒ image buffer cu Content-Type: image/jpeg
5. Stream-uieÈ™te fiÈ™ierul direct la client (efficient pentru files mari)

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:95-99
- Service: src/v1/User/Service/user.service.ts:339-345

Request:
GET /v1/user/profile-image?email=user@example.com
Headers: Authorization: Bearer {accessToken}

Query Parameters:
- email (string, required): user email (CURRENTLY IGNORED)

Response (Success 200):
Content-Type: image/jpeg
[Image Binary Data - JPEG stream]

Authorization: AuthGuard('jwt')

Rate Limiting: Default throttler

Dependencies:
- fs.createReadStream() - Node.js filesystem

Notes:
- IMPLEMENTARE INCOMPLETÄ‚: userId din query e ignorat
- ÃŽntotdeauna returneazÄƒ default-users.jpg
- POSIBIL BUG: Ar trebui sÄƒ verifice user.hasPicture È™i sÄƒ Ã®ncarce din DigitalOcean Spaces
- Codul comentat sugereazÄƒ cÄƒ era planificatÄƒ Ã®ncÄƒrcarea realÄƒ

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- VerificÄƒ user.hasPicture flag
- DacÄƒ true, download from DigitalOcean Spaces (users/{userId}.jpg)
- DacÄƒ false, returneazÄƒ default image
- Consider caching cu CDN

--------------------------------------------------------------------------------
TASK 6: PUT /v1/user/profile-image
--------------------------------------------------------------------------------

Title: PUT /v1/user/profile-image

Description:

Business Logic:
1. PrimeÈ™te multipart/form-data cu file upload
2. DOAR CLIENT role poate upload profile image (nu ADMIN)
3. ValideazÄƒ file type folosind file-type library:
   - Allowed: image/jpeg, image/jpg, image/png
   - DetecteazÄƒ MIME type din buffer (nu doar extension)
4. Upload file la DigitalOcean Spaces Ã®n directory users/
5. File name format: {userId}.jpg
6. SeteazÄƒ ACL la public-read pentru access public
7. ActualizeazÄƒ user.hasPicture = true Ã®n baza de date
8. ReturneazÄƒ success message
9. DacÄƒ file type e invalid, aruncÄƒ "FiÈ™ier invalid. Sunt permise doar fiÈ™ierele jpeg È™i png."

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:101-125
- Service: src/v1/User/Service/user.service.ts:347-372

Request:
PUT /v1/user/profile-image
Headers:
  Authorization: Bearer {accessToken}
  Content-Type: multipart/form-data

Form Data:
- file: [Binary Image Data]

Response (Success 200):
{
  "status": "ok",
  "message": "Imaginea de profil a fost actualizata."
}

Response (Error 400 - invalid file type):
{
  "statusCode": 400,
  "message": "FiÈ™ier invalid. Sunt permise doar fiÈ™ierele jpeg È™i png."
}

Response (Error - upload failed):
{
  "status": "error",
  "message": "Imaginea de profil nu a fost actualizata"
}

Response (Error 403 - not CLIENT):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.CLIENT) - DOAR CLIENT (nu ADMIN sau USER)

Rate Limiting: Default throttler

Dependencies:
- file-type package (fileTypeFromBuffer) - MIME type detection
- DOSpacesService.uploadFile()
- UsersRepository.save()

File Upload Details:
- Max size: 300MB (configurat Ã®n file.middleware)
- Directory: users/
- File name: {userId}.jpg
- ACL: public-read
- URL format: {SPACES_ENDPOINT}/users/{userId}.jpg

Notes:
- File validation se face pe MIME type real, nu pe extension
- Previne upload de fiÈ™iere redenumite (.exe â†’ .jpg)
- hasPicture flag e folosit pentru a determina dacÄƒ sÄƒ Ã®ncarce din Spaces sau default image
- File e procesat Ã®n file.middleware Ã®nainte de a ajunge Ã®n controller

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Add image size validation (width/height)
- Add compression pentru files mari
- Consider image optimization (resize, quality)
- Add versioning pentru cache busting

--------------------------------------------------------------------------------
TASK 7: PATCH /v1/user/update
--------------------------------------------------------------------------------

Title: PATCH /v1/user/update

Description:

Business Logic:
1. User-ul poate actualiza propriul profil (foloseÈ™te GetUser() decorator pentru authUser)
2. CÃ¢mpuri actualizabile: fullName, email, phone, birthdate, gender, marketingAgreement, whatsappAgreement
3. Logic complex pentru marketingAgreement:
   - DacÄƒ true â†’ subscribe la MailerLite
   - DacÄƒ false â†’ unsubscribe de la MailerLite
4. Logic special pentru email update:
   - DacÄƒ email-ul e diferit de cel curent, trimite verification email
   - Email verification URL: {domain}/auth/confirmation/email?token={emailValidationToken}
   - Template: 'mail-update'
5. ReturneazÄƒ updated user object
6. MailerLite errors sunt log-uite dar NU blocheazÄƒ update-ul

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:134-140
- Service: src/v1/User/Service/user.service.ts:380-443

Request:
PATCH /v1/user/update
Headers: Authorization: Bearer {accessToken}
Body:
{
  "fullName": "John Doe Updated",
  "email": "newemail@example.com",
  "phone": "+40999888777",
  "birthdate": "1990-01-15",
  "gender": "M",
  "marketingAgreement": true,
  "whatsappAgreement": false
}

Response (Success 200):
{
  "id": 123,
  "fullName": "John Doe Updated",
  "email": "newemail@example.com",
  "phone": "+40999888777",
  "birthdate": "1990-01-15",
  "gender": "M",
  "marketingAgreement": true,
  "whatsappAgreement": false,
  "updatedAt": "2024-01-20T10:30:00.000Z"
}

Authorization: AuthGuard('jwt')

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.updateUser()
- MailerLiteService.subscribeToMarketing() / unSubscribeFromMarketing()
- MailerService.sendMail() (pentru email verification)
- JWT signing pentru email validation token

Email Validation Token:
- Type: VALIDATION_EMAIL
- Expiration: 90 days (configurat Ã®n JWT settings)
- Payload: { id, role, email, type, createdAt }

Notes:
- Email update necesitÄƒ verificare (nu se schimbÄƒ imediat)
- MailerLite errors nu opresc update-ul (error handling graceful)
- marketingAgreement toggle-uieÈ™te subscription la newsletter
- simplifiedUpdate param (false by default) controleazÄƒ dacÄƒ se executÄƒ MailerLite/Email logic

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Add validation pentru phone format (Romanian format)
- Add validation pentru email format
- Consider rate limiting pe email updates (prevent spam)
- Add notification cÃ¢nd email e schimbat cu succes

--------------------------------------------------------------------------------
TASK 8: PATCH /v1/user/:userId
--------------------------------------------------------------------------------

Title: PATCH /v1/user/:userId

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. Admin poate actualiza orice user din sistem
3. Toate cÃ¢mpurile din UpdateUserDto sunt actualizabile
4. FUNCÈšIONALITATE EXTRA: DacÄƒ dto.subTypeId e prezent, creeazÄƒ automat subscription:
   - Retrieve subscription type details
   - CreeazÄƒ subscription cu status PAYMENT_ACCEPTED
   - SeteazÄƒ startDate = now, endDate = now + duration months
   - ActualizeazÄƒ user.status la HAS_SUBSCRIPTION
   - Refresh user access cache Ã®n Redis
   - AdaugÄƒ user la MailerLite group specific produsului
5. ReturneazÄƒ updated user object cu subscription-ul nou (dacÄƒ a fost creat)
6. DacÄƒ subscription type nu existÄƒ, log warning dar continuÄƒ cu update-ul user

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:142-154
- Service: src/v1/User/Service/user.service.ts:445-527

Request:
PATCH /v1/user/123
Headers: Authorization: Bearer {accessToken}
Body:
{
  "fullName": "Updated Name",
  "status": 2,
  "isActive": true,
  "subTypeId": 50  // Optional - creates subscription if provided
}

Response (Success 200):
{
  "id": 123,
  "fullName": "Updated Name",
  "status": 2,  // HAS_SUBSCRIPTION (updated if subTypeId provided)
  "isActive": true,
  "updatedAt": "2024-01-20T10:30:00.000Z"
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.updateUser()
- SubscriptionTypesRepository.getTypeById()
- SubscriptionsRepository.save()
- UsersRepository.activateUserSubStatus()
- RedisService (refresh access cache)
- MailerLiteService.retrieveOrCreateGroup() + subscribeToMarketing()

Subscription Creation Logic (when subTypeId provided):
1. Retrieve subscription type (price, duration, form, courseId, categoryId)
2. Calculate startDate (now) and endDate (now + duration months, default 12)
3. Create SubscriptionEntity:
   - subTypeId: from dto
   - form: from subscription type
   - courseId/categoryId: from subscription type
   - clientId: userId
   - totalCost: subscription type price
   - status: PAYMENT_ACCEPTED
   - observations: "Added by admin - patch user"
4. Update user status to HAS_SUBSCRIPTION
5. Refresh Redis access cache
6. Add to MailerLite product group (BUY_CAMPAIGN_SUFFIX + productName)

Notes:
- subTypeId e OPÈšIONAL - dacÄƒ lipseÈ™te, doar update user data
- Subscription e creatÄƒ INSTANT cu status PAYMENT_ACCEPTED (nu necesitÄƒ platÄƒ)
- Access cache e refreshed automat pentru user
- MailerLite group e creat automat dacÄƒ nu existÄƒ
- Observations field marcheazÄƒ cÄƒ subscription a fost adÄƒugatÄƒ de admin

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Add validation pentru conflicting subscriptions
- Consider transaction pentru user update + subscription creation
- Add audit log pentru admin actions
- Notify user prin email cÃ¢nd subscription e adÄƒugatÄƒ

--------------------------------------------------------------------------------
TASK 9: DELETE /v1/user/:userId
--------------------------------------------------------------------------------

Title: DELETE /v1/user/:userId

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. È˜terge complet user-ul din sistem (hard delete, NU soft delete)
3. È˜tergere CASCADÄ‚ Ã®n urmÄƒtoarea ordine:
   - Toate invoices asociate user-ului (customerId match)
   - Toate subscriptions asociate user-ului (client.id match)
   - User entity
4. ReturneazÄƒ success message
5. PERMANENT DELETE - nu poate fi undo

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:156-165
- Service: src/v1/User/Service/user.service.ts:549-556

Request:
DELETE /v1/user/123
Headers: Authorization: Bearer {accessToken}

Response (Success 200):
{
  "status": "ok",
  "message": "Account successfully deleted"
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- InvoicesRepository.delete()
- SubscriptionsRepository.delete()
- UsersRepository.deleteUser()

Deletion Order (IMPORTANT):
1. Invoices (foreign key: customerId)
2. Subscriptions (foreign key: client.id)
3. User

Notes:
- HARD DELETE - nu e soft delete (nu seteazÄƒ isActive=false)
- Cascading delete manual (nu database CASCADE)
- Analytics È™i Campaigns NU sunt È™terse (POSIBIL BUG/INCONSISTENÈšÄ‚)
- MailerLite subscription rÄƒmÃ¢ne (nu se unsubscribe)
- Stripe Customer rÄƒmÃ¢ne Ã®n Stripe (nu se È™terge)

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Consider SOFT DELETE instead (set isDeleted=true, deletedAt=now)
- Delete Stripe Customer also
- Unsubscribe from MailerLite
- Delete Analytics, Campaigns, Shortlist entries
- Add confirmation mechanism (prevent accidental deletes)
- Add audit log pentru admin deletes
- Consider data export Ã®nainte de delete (GDPR compliance)

--------------------------------------------------------------------------------
TASK 10: POST /v1/user/disable
--------------------------------------------------------------------------------

Title: POST /v1/user/disable

Description:

Business Logic:
1. User-ul poate dezactiva propriul cont (self-service)
2. FoloseÈ™te GetUser() decorator pentru authUser (nu poate disable alt user)
3. SeteazÄƒ user status sau isActive=false (implementarea exactÄƒ e Ã®n repository)
4. ReturneazÄƒ success message
5. Cont dezactivat = user nu mai poate face login

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:177-181
- Service: src/v1/User/Service/user.service.ts:544-547

Request:
POST /v1/user/disable
Headers: Authorization: Bearer {accessToken}
Body: {} (empty body)

Response (Success 200):
{
  "status": "ok",
  "message": "Account successfully disabled"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.USER) - orice user autentificat

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.disableUser()

Notes:
- Self-service disable (user disable propriul cont)
- NU È™terge datele, doar dezactiveazÄƒ contul
- User poate re-activa contul (probabil prin send-activation-mail)
- Different de DELETE (care È™terge permanent)

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Add confirmation step (prevent accidental disable)
- Send email notification cÃ¢nd cont e disabled
- Add reason field (why user disables account)
- Consider grace period (30 days Ã®nainte de delete permanent)

--------------------------------------------------------------------------------
TASK 11: POST /v1/user/send-activation-mail
--------------------------------------------------------------------------------

Title: POST /v1/user/send-activation-mail

Description:

Business Logic:
1. Trimite email de activare/reactivare pentru un user
2. PrimeÈ™te email Ã®n body DTO
3. VerificÄƒ dacÄƒ user-ul existÄƒ È™i dacÄƒ isActive=true (paradox: doar users activi pot primi activation mail)
4. GenereazÄƒ activation token JWT (type: VALIDATION_EMAIL)
5. Trimite email cu template 'mail-update' (POSIBIL BUG - ar trebui alt template)
6. Email conÈ›ine activation URL: {domain}/auth/activation/user?token={activateToken}
7. ReturneazÄƒ success message
8. DacÄƒ user nu e activ, aruncÄƒ "Banned accounts can not do activation mail processes"

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:183-186
- Service: src/v1/User/Service/user.service.ts:584-616

Request:
POST /v1/user/send-activation-mail
Body:
{
  "email": "user@example.com"
}

Response (Success 200):
{
  "status": "ok",
  "message": "Activation mail has been sent"
}

Response (Error 400 - banned account):
{
  "statusCode": 400,
  "message": "Banned accounts can not do activation mail processes"
}

Response (Error 400 - user not found):
{
  "statusCode": 400,
  "message": "User not found"
}

Authorization: Public (nu necesitÄƒ AuthGuard)

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.getUserByEmail()
- MailerService.sendMail()
- JWT signing (activateAccount secret)

Email Details:
- Subject: "Reactivate Your Account [{fullName}]"
- Template: 'mail-update' (PROBABIL GREÈ˜IT - ar trebui 'activation')
- Context: { emailUpdateAddress: activationUrl, fullName }
- Activation URL: {domain}/auth/activation/user?token={token}

Activation Token:
- Type: VALIDATION_EMAIL
- Secret: SECRET_FOR_ACTIVATE_ACCOUNT (different from other tokens)
- Expiration: configurat Ã®n auth.jwt.activateAccount
- Payload: { id, role, email, type, createdAt }

Notes:
- LOGIC STRANIU: verificÄƒ isActive=true dar trimite "activation" mail
- Probabil folosit pentru RE-activation dupÄƒ disable
- Template 'mail-update' e reutilizat (ar trebui template dedicat)
- Endpoint e PUBLIC - oricine poate solicita activation mail pentru orice email

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Rename la "send-reactivation-mail" pentru claritate
- Add rate limiting specific (prevent spam pe email)
- Use dedicated email template pentru reactivation
- Consider verificare cÄƒ user e disabled Ã®nainte de a trimite mail

--------------------------------------------------------------------------------
TASK 12: GET /v1/user/activate-user
--------------------------------------------------------------------------------

Title: GET /v1/user/activate-user

Description:

Business Logic:
1. ActiveazÄƒ user-ul folosind token-ul din query params
2. VerificÄƒ JWT token signature folosind access token secret
3. ValideazÄƒ cÄƒ token-ul conÈ›ine activationToken field
4. VerificÄƒ expiration time (remainingTime > 0)
5. ActiveazÄƒ user-ul Ã®n baza de date (seteazÄƒ probabil isActive=true)
6. ReturneazÄƒ success message
7. DacÄƒ token e invalid/expirat, aruncÄƒ "Activation token is not valid"
8. DacÄƒ signature e invalid, aruncÄƒ "Token signature is not valid"

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:188-191
- Service: src/v1/User/Service/user.service.ts:558-582

Request:
GET /v1/user/activate-user?token=eyJhbGc...

Query Parameters:
- token (string, required): JWT activation token

Response (Success 200):
{
  "status": "ok",
  "message": "Account has been activated"
}

Response (Error 400 - invalid signature):
{
  "statusCode": 400,
  "message": "Token signature is not valid"
}

Response (Error 400 - expired/invalid):
{
  "statusCode": 400,
  "message": "Activation token is not valid"
}

Authorization: Public (nu necesitÄƒ AuthGuard)

Rate Limiting: Default throttler

Dependencies:
- jwt.verify() - validate token signature
- UsersRepository.activateUser()

Token Validation:
- Secret: app.auth.jwt.accessToken.secret (POSIBIL BUG - ar trebui activateAccount secret)
- Checks: signature, expiration, activationToken field presence

Notes:
- Endpoint e PUBLIC - oricine cu token valid poate activa
- Token verification foloseÈ™te access token secret (inconsistenÈ›Äƒ cu send-activation-mail)
- activationToken field Ã®n payload e necesar (Ã®n plus faÈ›Äƒ de standard JWT claims)
- One-time use nu e enforced (token poate fi refolosit)

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Use consistent secret (activateAccount, nu accessToken)
- Enforce one-time token usage (invalidate dupÄƒ activate)
- Add logging pentru activation attempts
- Redirect to success page dupÄƒ activation (nu JSON response)

--------------------------------------------------------------------------------
TASK 13: GET /v1/user/send-mass-activation-mail
--------------------------------------------------------------------------------

Title: GET /v1/user/send-mass-activation-mail

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. BULK operation - trimite email de activare la TOÈšI users cu un anumit profileVersion
3. ProfileVersion e hardcodat Ã®n cod: 4914 (PROBABIL TEMPORAR/MIGRATION SPECIFIC)
4. Pentru fiecare user:
   - GenereazÄƒ recovery URL (folosind recoveryKey existent)
   - Trimite email cu template 'mass-reset-email'
   - IncrementeazÄƒ profileVersion cu 1
   - SalveazÄƒ user
5. Email subject: "ðŸŒ¸ O primÄƒvarÄƒ minunatÄƒ! VeÈ™ti bune de la Somaway ðŸŒ¿" (HARDCODAT)
6. ReturneazÄƒ numÄƒrul de emails trimise
7. ATENÈšIE: Bulk operation - poate dura mult pentru users mulÈ›i

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:193-197
- Service: src/v1/User/Service/user.service.ts:634-662

Request:
GET /v1/user/send-mass-activation-mail
Headers: Authorization: Bearer {accessToken}

Response (Success 200):
{
  "status": "ok",
  "message": "Activation mails have been sent 150"
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.getUsersForMassActivation(profileVersion)
- MailerService.sendMail() - called in loop
- UsersRepository.save() - called in loop

Email Details:
- Subject: "ðŸŒ¸ O primÄƒvarÄƒ minunatÄƒ! VeÈ™ti bune de la Somaway ðŸŒ¿"
- Template: 'mass-reset-email'
- Context: { accountRecoverAddress, fullName }
- Recovery URL: {domain}/auth/recuperare-cont?email={email}&recoveryKey={recoveryKey}

ProfileVersion Logic:
- Query: WHERE profileVersion = 4914 (HARDCODAT)
- After send: profileVersion += 1
- Purpose: Track care users au primit deja emailul (evitÄƒ re-send)

Notes:
- MIGRATION/CAMPAIGN SPECIFIC - profileVersion 4914 e hardcodat
- Nu e reutilizabil pentru alte campaniii fÄƒrÄƒ code change
- Email subject e hardcodat (specific campanie primÄƒvarÄƒ)
- FoloseÈ™te recovery key mechanism Ã®n loc de activation token
- Loop sincron - poate fi lent pentru mulÈ›i users
- NU are rate limiting pe emails (risc de spam flag)

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Make profileVersion param (nu hardcodat)
- Make email subject/template configurable
- Add batch processing (chunks of 50-100)
- Add delay Ã®ntre emails (prevent SMTP rate limiting)
- Add background job (Hangfire) pentru async processing
- Add progress tracking/reporting
- Add retry mechanism pentru failed emails
- Consider using bulk email API (MailerLite batch send)

--------------------------------------------------------------------------------
TASK 14: GET /v1/user/add-mass-users-mailerlite-groups
--------------------------------------------------------------------------------

Title: GET /v1/user/add-mass-users-mailerlite-groups

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. BULK operation - adaugÄƒ toÈ›i users Ã®n MailerLite groups bazat pe subscription status
3. Logic complex de grupare:
   - Users cu subscription activÄƒ â†’ group specific produsului (COMENTAT - disabled)
   - Users cu free subscription SAU expired subscription â†’ group "[free noiembrie 24 (fara abonament activ)]"
   - Users fÄƒrÄƒ subscription â†’ group "[free noiembrie 24 (fara abonament activ)]"
4. Active subscription = status >= PAYMENT_ACCEPTED && form != FREE && endDate >= now
5. Subscription types sunt Ã®ncÄƒrcate pentru a map subTypeId â†’ productName
6. Users sunt grupaÈ›i Ã®n batches per MailerLite group
7. Bulk add la MailerLite folosind addBulkSubscribersToGroup
8. ReturneazÄƒ numÄƒrul de users procesaÈ›i
9. MARE PARTE DIN COD E COMENTATÄ‚ (logic pentru active subs)

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:199-203
- Service: src/v1/User/Service/user.service.ts:664-774

Request:
GET /v1/user/add-mass-users-mailerlite-groups
Headers: Authorization: Bearer {accessToken}

Response (Success 200):
{
  "status": "ok",
  "message": "250 Users have been added to MailerLite groups"
}

Response (Error 400 - no subscription types):
{
  "status": "error",
  "message": "No subscription types found"
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.getUsersForMassMailerliteAttaching() - loads users with subscriptions
- SubscriptionTypesRepository.getAllTypesList()
- MailerLiteService.retrieveOrCreateGroup()
- MailerLiteService.addBulkSubscribersToGroup()

MailerLite Groups:
- "[free noiembrie 24 (fara abonament activ)]" - users without active subscription (HARDCODAT)
- (COMENTAT) BUY_CAMPAIGN_SUFFIX + productName - per product groups

Subscription Classification:
1. activeSubscriptions: status >= PAYMENT_ACCEPTED && form != FREE && endDate >= now
2. freeSubscriptions: form != FREE
3. (COMENTAT) expiredSubs: status >= PAYMENT_ACCEPTED && form != FREE && endDate < now
4. (COMENTAT) unFinishedSubs: status < PAYMENT_ACCEPTED && form != FREE

User Data Sent to MailerLite:
- email: user email
- fields.name: first word from fullName
- fields.last_name: second word from fullName (if exists)
- fields.phone: phone number

Notes:
- SPECIFIC CAMPAIGN - group name hardcodat pentru noiembrie 2024
- Bulk operation - proceseazÄƒ TOÈšI users dintr-o datÄƒ
- Active subscription logic e COMENTAT (doar free/no-sub e activ)
- Group creation e automatÄƒ (retrieveOrCreateGroup)
- Bulk add e eficient (un API call per group, nu per user)
- Nu e idempotent - re-run poate duplica users Ã®n groups

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Make group names configurable (nu hardcodat)
- Uncomment active subscription logic sau remove complet
- Add progress tracking
- Add logging per user processed
- Add error handling per user (skip failed, continue cu restul)
- Add background job (Hangfire) - async processing
- Add idempotency check (don't re-add if already in group)
- Consider incremental sync (doar new users sau changed subscriptions)

--------------------------------------------------------------------------------
TASK 15: POST /v1/user/create-by-admin
--------------------------------------------------------------------------------

Title: POST /v1/user/create-by-admin

Description:

Business Logic:
1. Endpoint disponibil DOAR pentru ADMIN role
2. Admin creeazÄƒ un user nou cu toate detaliile, inclusiv subscription opÈ›ional
3. VerificÄƒ dacÄƒ user-ul existÄƒ deja (email SAU phone)
4. CreeazÄƒ Stripe Customer ÃŽNAINTE de user (dependency)
5. GenereazÄƒ random password (16 bytes hex = 32 characters)
6. Hash-uieÈ™te password-ul cu Argon2
7. GenereazÄƒ recovery key pentru password setup
8. CreeazÄƒ user cu:
   - role: CLIENT (forced)
   - status: HAS_SUBSCRIPTION (forced)
   - isActive: true
   - marketingAgreement: true
   - profileVersion: 1
9. DACÄ‚ dto.subTypeId e prezent:
   - CreeazÄƒ subscription cu status PAYMENT_ACCEPTED
   - AdaugÄƒ user la MailerLite product group
10. AdaugÄƒ user la MailerLite group "[admin_created]"
11. Trimite email de "password setup" cu recovery URL
12. ReturneazÄƒ created user object

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:205-216
- Service: src/v1/User/Service/user.service.ts:776-970

Request:
POST /v1/user/create-by-admin
Headers: Authorization: Bearer {accessToken}
Body:
{
  "email": "newuser@example.com",
  "phone": "+40123456789",
  "fullName": "New User Name",
  "subTypeId": 50,  // Optional - creates subscription if provided
  "isActive": true  // Currently ignored - always true
}

Response (Success 200):
{
  "id": 789,
  "fullName": "New User Name",
  "email": "newuser@example.com",
  "phone": "+40123456789",
  "role": "CLIENT",
  "status": 2,  // HAS_SUBSCRIPTION
  "isActive": true,
  "stripeCustomer": "cus_xxx",
  "recoveryKey": "A1B2C3D4E5F6G7H8",
  "createdAt": "2024-01-20T10:30:00.000Z"
}

Response (Error 400 - user exists):
{
  "statusCode": 400,
  "message": "Un utilizator cu acest email sau telefon existÄƒ deja."
}

Response (Error 400 - Stripe failed):
{
  "statusCode": 400,
  "message": "Could not create Stripe customer: {error details}"
}

Response (Error 400 - subscription type not found):
{
  "statusCode": 400,
  "message": "The specified subscription type does not exist."
}

Response (Error 403 - not admin):
{
  "statusCode": 403,
  "message": "Forbidden resource"
}

Authorization:
- AuthGuard('jwt')
- @Roles(UserRoles.ADMIN) - DOAR ADMIN

Rate Limiting: Default throttler

Dependencies:
- UsersRepository.findOne() - check duplicate
- StripeService.createCustomer()
- UsersRepository.save()
- SubscriptionTypesRepository.getTypeById()
- SubscriptionsRepository.save()
- MailerLiteService.retrieveOrCreateGroup()
- MailerLiteService.subscribeToMarketing()
- MailerService.sendMail()
- crypto.randomBytes() - generate random password
- argon2.hash() - hash password

Stripe Customer Creation:
- email: lowercased
- name: fullName
- Returns: { id: "cus_xxx", ... }

Password Generation:
- randomBytes(16).toString('hex') = 32 character hex string
- Example: "a3f2e1d9c8b7a6f5e4d3c2b1a0987654"
- Hashed cu Argon2 Ã®nainte de stocare

Subscription Creation (dacÄƒ subTypeId e prezent):
- startDate: now
- endDate: now + duration months (default 12)
- status: PAYMENT_ACCEPTED (active imediat)
- totalCost: subscription type price
- observations: "Added by admin - create user"

MailerLite Groups:
1. "[admin_created]" - toÈ›i users creaÈ›i de admin
2. BUY_CAMPAIGN_SUFFIX + productName - dacÄƒ are subscription

Email Details:
- Subject: "ConfigureazÄƒ parola pentru contul tÄƒu Somaway"
- Template: 'admin-create-confirm'
- Context: { setPasswordUrl, fullName }
- Password Setup URL: {domain}/auth/recuperare-cont?email={email}&recoveryKey={recoveryKey}

Notes:
- User e creat ACTIV È™i cu subscription status (chiar dacÄƒ nu are subscription)
- Password e random - user TREBUIE sÄƒ foloseascÄƒ recovery URL pentru a seta password
- Recovery key e generat automat (16 chars uppercase alphanumeric)
- Stripe Customer e MANDATORY - dacÄƒ faileazÄƒ, user nu e creat
- MailerLite errors sunt log-uite dar NU blocheazÄƒ crearea user-ului
- dto.isActive e IGNORAT - Ã®ntotdeauna true (cod comentat sugereazÄƒ cÄƒ era planificatÄƒ altÄƒ logicÄƒ)

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Respect dto.isActive flag
- Add option pentru admin sÄƒ seteze password direct (nu doar recovery)
- Add transaction pentru user + subscription + Stripe (rollback if any fails)
- Consider sending welcome email dupÄƒ ce user-ul seteazÄƒ password
- Add validation pentru phone format (Romanian specific)
- Add audit log pentru admin user creation

--------------------------------------------------------------------------------
TASK 16: POST /v1/user/update-address
--------------------------------------------------------------------------------

Title: POST /v1/user/update-address

Description:

Business Logic:
1. User-ul poate crea/actualiza adresa de facturare
2. FoloseÈ™te GetUser() decorator pentru authUser
3. SeteazÄƒ customerId = authUser.id (nu poate seta address pentru alt user)
4. DacÄƒ adresa existÄƒ (match pe customerId), o actualizeazÄƒ
5. DacÄƒ adresa nu existÄƒ, o creeazÄƒ
6. CÃ¢mpuri address: streetAddress, city, state, postalCode, country, isDefault
7. ReturneazÄƒ success message

Cod sursÄƒ:
- Controller: src/v1/User/Controller/user.controller.ts:218-228
- Service: src/v1/User/Service/user.service.ts:982-986

Request:
POST /v1/user/update-address
Headers: Authorization: Bearer {accessToken}
Body:
{
  "streetAddress": "Str. Exemplu nr. 10",
  "city": "BucureÈ™ti",
  "state": "BucureÈ™ti",
  "postalCode": "012345",
  "country": "RomÃ¢nia",
  "isDefault": true
}

Response (Success 200):
{
  "status": "ok",
  "message": "Address updated successfully"
}

Authorization: AuthGuard('jwt')

Rate Limiting: Default throttler

Dependencies:
- AddressesRepository.createOrUpdateAddress()

Address DTO Fields:
- customerId: auto-set from authUser.id
- streetAddress: string
- city: string
- state: string
- postalCode: string
- country: string
- isDefault: boolean

Notes:
- Upsert operation (create if not exists, update if exists)
- Un user poate avea multiple addresses (isDefault flag selecteazÄƒ default)
- Address e folositÄƒ pentru invoices (SmartBill integration)
- No validation on address format/country

Posibile Ã®mbunÄƒtÄƒÈ›iri .NET:
- Add validation pentru postalCode format (per country)
- Add address validation API (verify address exists)
- Add support pentru multiple addresses per user
- Add address type (billing vs shipping)
- Consider autocomplete API pentru cities/streets

================================================================================
END OF STORY
================================================================================

Summary:
- Total Tasks: 16
- Total Endpoints: 16 (9 GET, 4 POST, 2 PATCH, 1 PUT, 1 DELETE)
- Admin-only Endpoints: 6 (all, export-all, search, patch user, delete, create-by-admin, mass operations)
- Public Endpoints: 2 (send-activation-mail, activate-user)
- Complex Features: Access control system cu Redis cache, CSV export, DigitalOcean Spaces integration, bulk operations
- Third-party Integrations: Stripe, MailerLite, DigitalOcean Spaces, Postmark

Migration Priority: HIGH (core user management, dependencies cu Auth È™i Subscription modules)
Estimated Story Points: 34

Special Notes:
- Access control system cu 4 levels (ADMIN, STANDARD, COURSE_BASED, NO_ACCESS)
- Redis caching pentru access rights È™i category permissions
- Profile image PARTIALLY IMPLEMENTED (download returneazÄƒ default, upload funcÈ›ioneazÄƒ)
- Mass operations sunt campaign-specific cu hardcoded values
- Delete e hard delete (considerÄƒ soft delete pentru .NET)
- CreateByAdmin e complex (Stripe + User + Subscription + MailerLite Ã®n acelaÈ™i flow)